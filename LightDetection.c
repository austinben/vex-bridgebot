#pragma config(Sensor, in1,    IR_SCANNER,     sensorReflection)
#pragma config(Sensor, in8,    ,               sensorAnalog)
#pragma config(Sensor, dgtl7,  button1,        sensorTouch)
#pragma config(Sensor, dgtl8,  button2,        sensorTouch)
#pragma config(Sensor, dgtl10, LED1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LED2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, limitSwitch,    sensorTouch)
#pragma config(Motor,  port6,           motor1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           motor2,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Ben Austin
ENGR 120 Design Lab
2018/03/05

Milestone 3, Part 1: Target Detection

Robot will turn untill the mounted phototransistors detecs that the robot is
facing the desiered target. It will then stop all movement and signal task
completion via a red LED mounted on the top of the robot.
*/

// Flags for buttons
bool button1_pushed = false;
bool button2_pushed = false;
bool limitSwitch_pushed = false;

//Threshhold value for light
const int maxLight = 2100;

//LED control values
const int ON = 1;
const int OFF = 0;

//Reset LED status to off.
void resetLightStatus() {
	SensorValue[LED1] = OFF;
	SensorValue[LED2] = OFF;
}

// Stops all movement of robot
void stop() {
	motor[motor1] = 0;
	motor[motor2] = 0;
}

bool monitorLight() {
	static int minLevel = 4096;	//Minimum light level seen by sensor
	static int maxLevel = 0; //Maximum light level seen by sensor
	static int diffLevel = 0; //Delta light level seen in last 0.1 seconds

	int lightLevel = SensorValue[IR_SCANNER];
	bool returnValue = false;

	// Check if 100 msecs have elapsed.
	if (time1[T1] > 100)  {
	  	// 100 msecs have elapsed.  Compute delta of light level.
		diffLevel = maxLevel - minLevel;

		// Reset calculation for next 100 msecs.
		maxLevel = 0;
		minLevel = 4096;
		clearTimer(T1);
	}
	else {

	  // Check for new minimum/maximum light levels.
	  if (lightLevel < minLevel) {
	  		minLevel = lightLevel;
	  }
	  else if (lightLevel > maxLevel) {
	  maxLevel = lightLevel;
	  }
	}

	// Check if light level difference over threshold.
	if (diffLevel > maxLight) {
		returnValue = true;
	}
	else {
	  returnValue = false;
	}

	// Returns whether or not IR light level is above the threshold
	return(returnValue);
}

// Declaration of states
task main() {
 	enum robotState {
	SCAN = 0,
	FOUND,
	};

	robotState scanState = SCAN; //Base state
	bool targetVisible = false; //  Init boolean to determine is target is visible
	resetLightStatus(); //Init the lights

	while (true) { // Infinite looping
		targetVisible = monitorLight(); //get a boolean return value
		switch (scanState) {
			case SCAN: // Case where robot is activeley looking for the beacon
				SensorValue[LED1] = OFF;
				if (targetVisible) {
					scanState = FOUND;
				}
				else {
					motor[motor1] = 30;
					motor[motor2] = 30;
				}
				break;

			case FOUND: // Case where robot has found the direction of beacon
				stop();
				SensorValue[LED1] = ON;
				if (targetVisible) {
					scanState = FOUND;
				}
				else {
					scanState = SCAN;
				}
				break;

				default:
					scanState = SCAN;
				// Should never reach this point
		}
	}
}
